{"meta":{"title":"chenwuai'blog","subtitle":"","description":"chnwuai blog","author":"chenwuai","url":"https://chenchenwuai.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-09-11T09:34:44.151Z","updated":"2020-09-11T09:34:44.151Z","comments":true,"path":"404.html","permalink":"https://chenchenwuai.github.io/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-09-11T09:34:44.164Z","updated":"2020-09-11T09:34:44.164Z","comments":false,"path":"about/index.html","permalink":"https://chenchenwuai.github.io/about/","excerpt":"","text":"chenwuai 后端 php NodeJs 前端 vue全家桶 html+css"},{"title":"收藏","date":"2020-10-27T10:15:59.602Z","updated":"2020-10-27T10:15:59.602Z","comments":false,"path":"recommends/index.html","permalink":"https://chenchenwuai.github.io/recommends/","excerpt":"","text":"收藏 软件 VsCode 网站"},{"title":"categories","date":"2020-07-02T12:36:39.000Z","updated":"2020-09-11T09:34:44.167Z","comments":true,"path":"categories/index.html","permalink":"https://chenchenwuai.github.io/categories/","excerpt":"","text":""},{"title":"tags","date":"2020-07-02T12:42:16.000Z","updated":"2020-09-11T09:34:44.173Z","comments":true,"path":"tags/index.html","permalink":"https://chenchenwuai.github.io/tags/","excerpt":"","text":""},{"title":"Friends","date":"2020-09-11T09:34:44.169Z","updated":"2020-09-11T09:34:44.169Z","comments":true,"path":"friends/index.html","permalink":"https://chenchenwuai.github.io/friends/","excerpt":"","text":"各位大佬想交换友链的话，请先添加我的友链后，在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： chenwuai’s blog头像： https://i.loli.net/2020/07/02/JKNsSczEb68Rlvj.gif网址： https://chenchenwuai.github.io/标签： 前端 php"},{"title":"影视","date":"2020-09-24T03:46:13.863Z","updated":"2020-09-24T03:46:13.863Z","comments":false,"path":"video/index.html","permalink":"https://chenchenwuai.github.io/video/","excerpt":"","text":"电影/电视剧 恶之花 악의 꽃 (2020)讲述为隐藏残酷过往而改变形象的男子，与追踪其过往的重案组刑警结婚后的故事。李准基饰演看似为妻子和女儿无私付出的居家型男，但实际上不带感情去欺骗妻子而得到现有的一切，文彩元饰演深爱着丈夫的天真妻子，却要遭遇亲手为丈夫上手铐逮捕。 Rate：★★★★☆ 9.1Date：2020-09-24 已看 异星灾变 第一季 Raised by Wolves Season 1 (2020)故事讲述两个机器人授命在一个神秘星球抚育人类后代，随着宗教差异导致的分崩离析，机器人发现控制人类信仰是一件极度危险的事情。斯科特表示：“我一直在寻找科幻题材的新疆界，这部剧集将展现一个与众不同、充满想象力的世界，同时这部剧也提出了这样的问题：是什么让我们成为了人类？是什么构成了一个家庭？如果我们能重新来过、消除我们所在星球的混乱会怎么样？我们能幸存下去吗？我们能做得更好吗？” Rate：★★★★☆ 9.0Date：2020-09-15 已看"}],"posts":[{"title":"CSS中的 BFC 是什么？","slug":"front-end/CSS_What-Is-BFC","date":"2020-10-27T13:00:00.000Z","updated":"2020-10-27T10:14:28.431Z","comments":true,"path":"front-end/CSS_What-Is-BFC/","link":"","permalink":"https://chenchenwuai.github.io/front-end/CSS_What-Is-BFC/","excerpt":"BFC: 块级格式化上下文 (Block Formatting Context)","text":"BFC: 块级格式化上下文 (Block Formatting Context) 建议先理解CSS的盒模型 什么是BFCBFC是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。W3C对BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，通俗的说可以把BFC理解为一个封闭的箱子，箱子内部的元素无论怎么放置，都不会影响到外部。并且在一个 BFC 中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 下列方式会创建BFC： 根元素（&lt;html&gt;） 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值） 表格标题 （元素的 display 为 table-caption，HTML表格标题默认为该值） display 值为 flow-root 的元素 匿名表格单元格元素（元素的 display 为 table、``table-row、 table-row-group、``table-header-group、``table-footer-group（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table） overflow 值不为 visible 的块元素 contain 值为 layout、content或 paint 的元素 弹性元素（display 为 flex 或 inline-flex元素的直接子元素） 网格元素（display 为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 ``column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）（未验证）。 BFC的特性 BFC内部的块级盒会在垂直方向上一个接一个排列。（普通流） 计算BFC的高度时，浮动元素也会参与计算。 同一BFC下的相邻块级元素可能发生外边距折叠。(float可以避免外边距折叠 或者 打破同一BFC的结构) BFC元素不会和它的子元素发生外边距折叠。 浮动盒的区域不会和BFC重叠。 BFC是一个独立的容器外面的元素不会影响BFC内部反之亦然。 BFC的作用清除内部浮动未完待续…","categories":[{"name":"CSS","slug":"CSS","permalink":"https://chenchenwuai.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://chenchenwuai.github.io/tags/CSS/"},{"name":"BFC","slug":"BFC","permalink":"https://chenchenwuai.github.io/tags/BFC/"}]},{"title":"CSS 盒模型详解 + 定位规则","slug":"front-end/CSS_Box_Model","date":"2020-10-27T11:05:04.000Z","updated":"2020-10-27T09:12:49.464Z","comments":true,"path":"front-end/CSS_Box_Model/","link":"","permalink":"https://chenchenwuai.github.io/front-end/CSS_Box_Model/","excerpt":"浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model）对html文档进行渲染，将所有元素表示为一个个矩形的盒子（box）。CSS 决定这些盒子的大小、位置以及属性（例如颜色、背景、边框尺寸…）。","text":"浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model）对html文档进行渲染，将所有元素表示为一个个矩形的盒子（box）。CSS 决定这些盒子的大小、位置以及属性（例如颜色、背景、边框尺寸…）。 盒模型所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。CSS盒模型本质上是一个盒子，包括 内容区域(content)、内边距区域(padding)、边框区域(border)、外边距区域(margin)。 内容区域 由内容边界限制，容纳着元素的“真实”内容，例如文本、图像，或是一个视频播放器。如果 box-sizing 为 content-box（默认），则内容区域的大小可明确地通过 width、min-width、max-width、height、min-height 和 max-height 控制。 *内边距区域 * 由内边距边界限制，扩展自内容区域，负责延伸内容区域的背景，填充元素中内容与边框的间距。内边距的粗细可以由 padding-top、padding-right、padding-bottom、padding-left，和简写属性 padding 控制。 边框区域 由边框边界限制，扩展自内边距区域，是容纳边框的区域。边框的粗细由 border-width和简写的 border 属性控制。如果 box-sizing 属性被设为 border-box，那么边框区域的大小可明确地通过 width、min-width, max-width、height、min-height，和 max-height 属性控制。假如框盒上设有背景（background-color或 background-image），背景将会一直延伸至边框的外沿（默认为在边框下层延伸，边框会盖在背景上）。此默认表现可通过 CSS 属性 background-clip 来改变。 外边距区域 由外边距边界限制，用空白区域扩展边框区域，以分开相邻的元素。外边距区域的大小由 margin-top、margin-right、margin-bottom、margin-left，和简写属性 margin 控制。在发生外边距合并的情况下，由于盒之间共享外边距，外边距不容易弄清楚。 盒模型又分为 标准盒模型 和 怪异盒模型 标准盒模型标准盒模型是W3C的标准，box-sizing 为 content-box，这是默认值，盒子的width等于content的宽度。 怪异盒模型怪异盒模型又叫做ie盒模型，它是ie的标准，box-sizing 为 border-box， 盒子的width等于content + padding + border的宽度。 视觉格式化模型CSS 视觉格式化模型（visual formatting model）是用来处理和在视觉媒体上显示文档时使用的计算规则。 视觉格式化模型会根据CSS盒子模型将文档中的元素转换为一个个盒子，每个盒子的布局由以下因素决定： 盒子的尺寸：精确指定、由约束条件指定或没有指定 盒子的类型：行内盒子（inline）、行内级盒子（inline-level）、原子行内级盒子（atomic inline-level）、块盒子（block） 定位方案（positioning scheme）：普通流定位、浮动定位或绝对定位 文档树中的其它元素：即当前盒子的子元素或兄弟元素 视口尺寸与位置 所包含的图片的尺寸 其他的某些外部因素 该模型会根据盒子的边界来渲染盒子，通常盒子会创建一个包含其子元素的包含块，但是子元素并不由包含块所限制，当子元素跑到包含块的外面时称为溢出（overflow）。 盒子的生成是 CSS 视觉格式化模型的一部分，用于从文档元素生成盒子。盒子有不同的类型，盒子的类型取决于 display 属性。 下面是一些基础概念 块：block，一个抽象的概念，一个块在文档流上占据一个独立的区域，块与块之间在垂直方向上按照顺序依次堆叠。 包含块：containing block，包含其他盒子的块称为包含块。 盒子：box，一个抽象的概念，由CSS引擎根据文档中的内容所创建，主要用于文档元素的定位、布局和格式化等用途。盒子与元素并不是一一对应的，有时多个元素会合并生成一个盒子，有时一个元素会生成多个盒子（如匿名盒子）。 块级元素：block-level element，元素的 display 为 block、list-item、table 时，该元素将成为块级元素。元素是否是块级元素仅是元素本身的属性，并不直接用于格式化上下文的创建或布局。 块级盒子：block-level box，由块级元素生成。一个块级元素至少会生成一个块级盒子，但也有可能生成多个（例如列表项元素）。 块盒子：block box，如果一个块级盒子同时也是一个块容器盒子（见下），则称其为块盒子。除具名块盒子之外，还有一类块盒子是匿名的，称为匿名块盒子（Anonymous block box），匿名盒子无法被CSS选择符选中。 块容器盒子：block container box或block containing box，块容器盒子侧重于当前盒子作为“容器”的这一角色，它不参与当前块的布局和定位，它所描述的仅仅是当前盒子与其后代之间的关系。换句话说，块容器盒子主要用于确定其子元素的定位、布局等。 注意：盒子分为“块盒子”和“块级盒子”两种，但元素只有“块级元素”，而没有“块元素”。下面的“行内级元素”也是一样。 行内级元素：inline-level element，display 为 inline、inline-block、inline-table 的元素称为行内级元素。与块级元素一样，元素是否是行内级元素仅是元素本身的属性，并不直接用于格式化上下文的创建或布局。 行内级盒子：inline-level box，由行内级元素生成。行内级盒子包括行内盒子和原子行内级盒子两种，区别在于该盒子是否参与行内格式化上下文的创建。 行内盒子：inline box，参与行内格式化上下文创建的行内级盒子称为行内盒子。与块盒子类似，行内盒子也分为具名行内盒子和匿名行内盒子（anonymous inline box）两种。 原子行内级盒子：atomic inline-level box，不参与行内格式化上下文创建的行内级盒子。原子行内级盒子一开始叫做原子行内盒子（atomic inline box），后被修正。原子行内级盒子的内容不会拆分成多行显示。 块盒子当元素的 display 为 block、list-item 或 table 时，该元素将成为块级元素。一个块级元素会被格式化成一个块（例如文章的一个段落），默认按照垂直方向依次排列。 每个块级盒子都会参与BFC 块格式化上下文（block formatting context）的创建，而每个块级元素都会至少生成一个块级盒子，即主块级盒子（principal block-level box）。有一些元素，比如列表项会生成额外的盒子来放置项目符号，而那些会生成列表项的元素可能会生成更多的盒子。不过，多数元素只生成一个主块级盒子。 主块级盒子包含由后代元素生成的盒子以及内容，同时它也会参与定位方案。 一个块级盒子可能也是一个块容器盒子。块容器盒子（block container box）要么只包含其它块级盒子，要么只包含行内盒子并同时创建一个行内IFC 格式化上下文（inline formatting context）。 块级盒子与块容器盒子的不同点是前者描述了元素与其父元素和兄弟元素之间的行为，而后者描述了元素跟其后代之间的行为。有些块级盒子并不是块容器盒子，比如表格；而有些块容器盒子也不是块级盒子，比如非替换行内块和非替换表格单元格。 一个同时是块容器盒子的块级盒子称为块盒子（block box）。 匿名块盒子在某些情况下进行视觉格式化时，需要添加一些增补性的盒子，这些盒子不能用CSS选择符选中，因此称为匿名盒子（anonymous boxes）。 CSS选择器不能作用于匿名盒子(anonymous boxes)，所以它不能被样式表赋予样式。也就是说，此时所有可继承的 CSS 属性值都为 inherit ，而所有不可继承的 CSS 属性值都为 initial。 块包含盒子可能只包含行内级盒子，也可能只包含块级盒子，但通常的文档都会同时包含两者，在这种情况下，就会在相邻的行内级盒子外创建匿名块盒子。 考虑下面的HTML代码，假设&lt;div&gt;和&lt;p&gt;都保持默认的样式（即它们的 display 为 block）： 1&lt;div&gt;Some inline text &lt;p&gt;followed by a paragraph&lt;/p&gt; followed by more inline text.&lt;/div&gt; 此时会产生两个匿名块盒子：一个是 &lt;p&gt; 元素前面的那些文本（Some inline text），另一个是 &lt;p&gt; 元素后面的文本（followed by more inline text.）。此时会生成下面的块结构： 显示为： 123Some inline textfollowed by a paragraphfollowed by more inline text. 对这两个匿名盒子来说，程序员无法像&lt;p&gt;元素那样控制它们的样式，因此它们会&lt;div&gt;从那里继承那些可继承的属性，如 color。其他不可继承的属性则会设置为 initial，比如，因为没有为它们指定 background-color，因此其具有默认的透明背景，而 &lt;p&gt; 元素的盒子则能够用CSS指定背景颜色。类似地，两个匿名盒子的文本颜色总是一样的。 另一种会创建匿名块盒子的情况是一个行内盒子中包含一或多个块盒子。此时，包含块盒子的盒子会拆分为两个行内盒子，分别位于块盒子的前面和后面。块盒子前面的所有行内盒子会被一个匿名块盒子包裹，块盒子后面的行内盒子也是一样。因此，块盒子将成为这两个匿名块盒子的兄弟盒子。 如果有多个块盒子，而它们中间又没有行内元素，则会在这些盒子的前面和后面创建两个匿名块盒子。 考虑下面的HTML代码，假设&lt;p&gt;的 display 为 inline，&lt;span&gt;的 display 为 block： 1&lt;p&gt;Some &lt;em&gt;inline&lt;/em&gt; text &lt;span&gt;followed by a paragraph&lt;/span&gt; followed by more inline text.&lt;/p&gt; 此时会产生两个匿名块盒子：一个是 &lt;span&gt; 元素前面的文本（Some *inline* text），另一个是其之后的文本（followed by more inline text.）。此时会生成下面的块结构： 显示为： 123Some inline textfollowed by a paragraphfollowed by more inline text. 行内盒子如果一个元素的 display 属性为 inline、inline-block 或 inline-table，则称该元素为行内级元素。显示时，它不会生成内容块，但是可以与其他行内级内容一起显示为多行。一个典型的例子是包含多种格式内容（如强调文本、图片等）的段落，就可以由行内级元素组成。 行内级元素会生成行内级盒子，该盒子同时会参与行内格式化上下文（inline formatting context）的创建。行内盒子既是行内级盒子，也是一个其内容会参与创建其容器的行内格式化上下文的盒子，比如所有具有 display:inline 样式的非替换盒子。如果一个行内级盒子的内容不参与行内格式化上下文的创建，则称其为原子行内级盒子。而通过替换行内级元素或 display 值为 inline-block 或 inline-table 的元素创建的盒子不会像行内盒子一样可以被拆分为多个盒子。 在同一个行内格式化上下文中，原子行内级盒子不能拆分成多行, 例如： 123456789&lt;style&gt; span &#123; display:inline; /* default value*/ &#125;&lt;/style&gt;&lt;div style=\"width:20em;\"&gt; The text in the span &lt;span&gt;can be split in several lines as it&lt;/span&gt; is an inline box.&lt;/div&gt; 上述代码可能显示为： 12The text in the span can be split into severallines as it is an inline box. 而 123456789&lt;style&gt; span &#123; display:inline-block; &#125;&lt;/style&gt;&lt;div style=\"width:20em;\"&gt; The text in the span &lt;span&gt;cannot be split in several lines as it&lt;/span&gt; is an inline-block box.&lt;/div&gt; 则可能显示为： 123The text in the span cannot be split into several lines as it is aninline-block box. 其中的“cannot be split into several lines as it”永远不会换行。 匿名行内盒子类似于块盒子，CSS引擎有时候也会自动创建一些行内盒子。这些行内盒子无法被选择符选中，因此是匿名的，它们从父元素那里继承那些可继承的属性，其他属性保持默认值 initial。 一种常见的情况是CSS引擎会自动为直接包含在块盒子中的文本创建一个行内格式化上下文，在这种情况下，这些文本会被一个足够大的匿名行内盒子所包含。但是如果仅包含空格则有可能不会生成匿名行内盒子，因为空格有可能会由于 white-space 的设置而被移除，从而导致最终的实际内容为空。 其他类型盒子还有其他类型的盒子例如：行盒子、Run-in盒子、表格包装器盒子、表格盒子、表格标题盒子、列盒子等等 定位规则一旦生成了盒子以后，CSS引擎就需要定位它们以完成布局。下面是定位盒子时所使用的规则： 普通流：按照次序依次定位每个盒子 浮动：将盒子从普通流中单独拎出来，将其放到外层盒子的某一边 绝对定位：按照绝对位置来定位盒子，其位置根据盒子的包含元素所建立的绝对坐标系来计算，因此绝对定位元素有可能会覆盖其他元素 普通流在普通流中，盒子会依次放置。在块格式化上下文中，盒子在垂直方向依次排列；而在行内格式化上下文中，盒子则水平排列。当CSS的 position 属性为 static 或 relative，并且 float 为 none 时，其布局方式为普通流。 浮动在浮动定位中，浮动盒子会浮动到当前行的开始或尾部位置。这会导致普通流中的文本及其他内容会“流”到浮动盒子的边缘处，除非元素通过 clear 清除了前面的浮动。 一个盒子的 float 值不为 none，并且其 position 为 static 或 relative 时，该盒子为浮动定位。如果将 float 设置为 left，浮动盒子会定位到当前行盒子的开始位置（左侧），如果设置为 right，浮动盒子会定位到当前行盒子的尾部位置（右侧）。不管是左浮动还是右浮动，行盒子都会伸缩以适应浮动盒子的大小。 绝对定位在绝对定位中，盒子会完全从当前流中移除，并且不会再与其有任何联系（此处仅指定位和位置计算，而绝对定位的元素在文档树中仍然与其他元素有父子或兄弟等关系），其位置会使用 top、bottom、left 和 right 相对其包含块进行计算。 如果元素的 position 为 absolute 或 fixed，该元素为绝对定位。 对固定位置的元素来说，其包含块为整个视口，该元素相对视口进行绝对定位，因此滚动时元素的位置并不会改变。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://chenchenwuai.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://chenchenwuai.github.io/tags/CSS/"},{"name":"盒模型","slug":"盒模型","permalink":"https://chenchenwuai.github.io/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"}]},{"title":"解决 Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2）的方法","slug":"php/Can't connect to local MySQL","date":"2020-10-10T02:17:00.000Z","updated":"2020-10-10T03:12:35.886Z","comments":true,"path":"php/Can't connect to local MySQL/","link":"","permalink":"https://chenchenwuai.github.io/php/Can't%20connect%20to%20local%20MySQL/","excerpt":"PHP连接MySQL报错：SQLSTATE[HY000] [2002] Can’t connect to local MySQL server through socket ‘MySQL’ (2)","text":"PHP连接MySQL报错：SQLSTATE[HY000] [2002] Can’t connect to local MySQL server through socket ‘MySQL’ (2) 一.问题发现今天在服务器上同时安装了mysql和mariadb，经过一番操作之后，发现原来的php程序不能连接mysql了，每次连接就会提示 1SQLSTATE[HY000] [2002] Can&#39;t connect to local MySQL server through socket &#39;MySQL&#39; (2) 在网上找了很多解决方法（csdn越来越垃圾了，都是千篇一律的复制粘贴，没有真正解决问题的），么有找到方法，在google找了几个解决方法，经过测试可以使用，并明白了原理。 二.问题解析如果提示这个错误，如果将连接参数中的localhost换成 127.0.0.1就能正常使用，这是为什么呢？这是因为使用localhost是通过套接字(socket)通讯，而127.0.0.1是通过tcp/ip协议通讯，而mysql的报错就是没有找到这个套接字文件(mysql.sock)，一般出现这种情况是因为（个人总结，可能还有其他原因，欢迎补充） 有些安装mysql的方法没有将此文件放在了其他位置,php连接mysql时没有找到这个文件 php没有访问这个文件的权限 这个文件被删除了 三.问题解决找到问题了，现在就要解决问题首先既然php找不到这个文件，那我们先全局找一下这个文件在哪儿 1sudo find / -name mysql.sock 如果没找到这个文件，尝试搜索一下 mysqld.sock 1sudo find / -name mysqld.sock 找到以上两个文件的任一文件，首先记一下文件的绝对路径， 我这边找到的是 /usr/local/mysql/data/mysqld.sock 如果没有找到，需要自己从其他地方复制一份，这个需要自己去搜索解决方法 我找到了两种解决方法 1.修改php.ini打开php的配置文件, 一般是/etc/php.ini，然后找到[MYSQL]段落，下面有一个mysql.default_socket，将上面记录的socket文件的绝对路径填写到 等号后面。 1mysql.default_socket= /usr/local/mysql/data/mysqld.sock 然后再找到[Pdo_mysql]段落，下面有一个pdo_mysql.default_socket，将上面记录的socket文件的绝对路径填写到 等号后面。 1pdo_mysql.default_socket= /usr/local/mysql/data/mysqld.sock 修改好之后，保存退出。重启apache或者nginx，必须要重启，不然不生效。再次测试连接mysql，看是否已经正常。 2.设置软连接（推荐）执行命令即可 1sudo ln -s /usr/local/mysql/data/mysqld.sock /var/lib/mysql/mysql.sock 前一个地址是mysql.sock或mysqld.sock的绝对路径，后一个路径为php没有找到socket文件的路径，我这边是/var/lib/mysql/mysql.sock,执行过命令之后，再次重新连接一下mysql，看是否已经正常。","categories":[{"name":"php","slug":"php","permalink":"https://chenchenwuai.github.io/categories/php/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://chenchenwuai.github.io/tags/mysql/"},{"name":"php","slug":"php","permalink":"https://chenchenwuai.github.io/tags/php/"},{"name":"mysql.sock","slug":"mysql-sock","permalink":"https://chenchenwuai.github.io/tags/mysql-sock/"}]},{"title":"TypeScript学习(2)-接口","slug":"typescript/typescript-learning-2","date":"2020-09-24T10:36:22.000Z","updated":"2020-09-24T07:10:45.401Z","comments":true,"path":"typescript/typescript-learning-2/","link":"","permalink":"https://chenchenwuai.github.io/typescript/typescript-learning-2/","excerpt":"搬运TypeScript中文网 - 接口为了方便，无特殊说明，以下的js表示 JavaScript，ts表示TypeScript","text":"搬运TypeScript中文网 - 接口为了方便，无特殊说明，以下的js表示 JavaScript，ts表示TypeScript 介绍TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 简单接口示例12345678910interface LabelledValue &#123; label: string;&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: \"Size 10 Object\"&#125;;printLabel(myObj); 可选属性接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用option bags模式时很常用，即给函数传入的参数对象中只有部分属性赋值了 1234interface SquareConfig &#123; color?: string; width?: number;&#125; 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。 只读属性一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性: 1234interface Point &#123; readonly x: number; readonly y: number;&#125; 你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。 12let p1: Point = &#123; x: 10, y: 20 &#125;;p1.x = 5; // error! TypeScript具有ReadonlyArray&lt;T&gt;类型，它与Array&lt;T&gt;相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： 123456let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!ro.push(5); // error!ro.length = 100; // error!a = ro; // error! 上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写： 1a = ro as number[]; readonly vs const最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly 额外的属性检查参考下一个例子： 12345678910interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let mySquare = createSquare(&#123; colour: \"red\", width: 100 &#125;); 注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。 你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。 然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误,error: &#39;colour&#39; not expected in type &#39;SquareConfig&#39;。绕开这些检查非常简单。 最简便的方法是使用类型断言： 1let mySquare = createSquare(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig); 然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它： 12345interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125; 我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。 12let squareOptions = &#123; colour: \"red\", width: 100 &#125;;let mySquare = createSquare(squareOptions); 要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。 函数类型接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 123interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。 12345let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125; 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子： 12345let mySearch: SearchFunc;mySearch = function(src: string, sub: string): boolean &#123; let result = src.search(sub); return result &gt; -1;&#125; 函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。 12345let mySearch: SearchFunc;mySearch = function(src, sub) &#123; let result = src.search(sub); return result &gt; -1;&#125; 可索引的类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子： 12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; 上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。 TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致 123456789101112class Animal &#123; name: string;&#125;class Dog extends Animal &#123; breed: string;&#125;// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!interface NotOkay &#123; [x: number]: Animal; [x: string]: Dog;&#125; 字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[&quot;property&quot;]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示： 12345interface NumberDictionary &#123; [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，`name`的类型与索引类型返回值的类型不匹配&#125; 最后，你可以将索引签名设置为只读，这样就防止了给索引赋值： 12345interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];myArray[2] = \"Mallory\"; // error! 你不能设置myArray[2]，因为索引签名是只读的。 类类型实现接口与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。 12345678interface ClockInterface &#123; currentTime: Date;&#125;class Clock implements ClockInterface &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样： 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 类静态部分与实例部分的区别当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误： 12345678interface ClockConstructor &#123; new (hour: number, minute: number);&#125;class Clock implements ClockConstructor &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。 因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。 1234567891011121314151617181920212223242526interface ClockConstructor &#123; new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick();&#125;function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log(\"beep beep\"); &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log(\"tick tock\"); &#125;&#125;let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32); 因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。 继承接口和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 1234567891011interface Shape &#123; color: string;&#125;interface Square extends Shape &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = \"blue\";square.sideLength = 10; 一个接口可以继承多个接口，创建出多个接口的合成接口。 12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; 混合类型先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。 一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。 接口继承类当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例： 123456789101112131415161718192021222324class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123; &#125;&#125;class TextBox extends Control &#123; select() &#123; &#125;&#125;// 错误：“Image”类型缺少“state”属性。class Image implements SelectableControl &#123; select() &#123; &#125;&#125;class Location &#123;&#125; 在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。 在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。","categories":[{"name":"前端","slug":"前端","permalink":"https://chenchenwuai.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://chenchenwuai.github.io/tags/TypeScript/"}]},{"title":"推荐几个实用或好玩的js脚本","slug":"javascript/Fun-JS-scripts","date":"2020-09-23T12:55:00.000Z","updated":"2020-10-10T03:19:32.860Z","comments":true,"path":"javascript/Fun-JS-scripts/","link":"","permalink":"https://chenchenwuai.github.io/javascript/Fun-JS-scripts/","excerpt":"简单的几个脚本,不像TamperMonkey那样强植入, 也无需安装浏览器扩展插件.","text":"简单的几个脚本,不像TamperMonkey那样强植入, 也无需安装浏览器扩展插件. 脚本列表如果未来有新脚本, 会陆续在这里更新.具体使用方法在页面底部 解除网页禁止复制的限制（同时去除复制内容末尾自动附加的额外小尾巴信息1javascript:window.oncontextmenu=document.oncontextmenu=document.oncopy=null; [...document.querySelectorAll('body')].forEach(dom =&gt; dom.outerHTML = dom.outerHTML); [...document.querySelectorAll('body, body *')].forEach(dom =&gt; &#123;['onselect', 'onselectstart', 'onselectend', 'ondragstart', 'ondragend', 'oncontextmenu', 'oncopy'].forEach(ev =&gt; dom.removeAttribute(ev)); dom.style['user-select']='auto';&#125;); 密码输入框明文显示（方便查看被浏览器记住但自己已经忘了的密码）1javascript:[...document.querySelectorAll('input[type=password]')].forEach(i =&gt; i.type = 'text'); 给网页内所有元素添加随机颜色外框线1javascript:[...document.querySelectorAll('*')].forEach(i =&gt; &#123; let rand = (~~(Math.random() * 0xFFFFFF)).toString(16); rand = '#' + ('00000' + rand).slice(-6); i.style.outline = '1px solid ' + rand; &#125;); 点击页面随机出现向上浮动并淡出的小字1javascript:(()=&gt;&#123;if(document.querySelector('#clickAnimation_')) return; var rand=()=&gt;&#123;var arr=['富强', '民主', '文明', '和谐', '自由', '平等', '公正', '法治', '爱国', '敬业', '诚信', '友善']; return arr[~~(Math.random()*arr.length)];&#125;; var s=document.createElement('style'); s.id='clickAnimation_'; s.innerText='.click-elem-t &#123;position: absolute; z-index: 9999; color: #f5871f; font-size: 15px; font-weight: bold; cursor: default; user-select: none; animation: floatAndGone 1.7s forwards;&#125; @keyframes floatAndGone &#123;from &#123;transform: translateY(0); opacity: 1;&#125; to &#123;transform: translateY(-75px); opacity: 0;&#125;&#125;'; document.querySelector('head').appendChild(s); document.body.addEventListener('click', e=&gt;&#123;var dom=document.createElement('span'); dom.innerText=rand(); dom.className='click-elem-t'; dom.style.top=e.pageY-25+'px'; dom.style.left=e.pageX+'px'; document.body.appendChild(dom); setTimeout(()=&gt;&#123;document.body.removeChild(dom)&#125;, 2200) &#125;);&#125;)(); 解除所有按钮的禁用状态1javascript:[...document.querySelectorAll('input[type=button], button')].forEach(i =&gt; i.removeAttribute('disabled')); 解除所有文本输入框/单选框/复选框的只读和禁用状态1javascript:[...document.querySelectorAll('textarea, input')].forEach(i =&gt; &#123; i.removeAttribute('disabled'); i.removeAttribute('readonly') &#125;); 如果你想要其他脚本，在评论区回复吧. 使用方法以下三种方法可任选其一 直接复制脚本代码，然后粘贴浏览器的地址栏，然后回车确定（chrome浏览器会去掉前面的 javascript 字母，需要手动加上，部分浏览器的地址栏可能不支持输入脚本）。（如果你想快速体验，可选择这一种） 复制脚本代码，然后新建浏览器书签，将代码粘贴到网址的输入框内，名字自己定义，然后保存。打开你需要操作的网页，然后再点击选择此书签。ok！（如果你以后也有使用的需求，可选择这一种） 如果你会一点前端调试功能，可以直接打开网页的console，(chrome按F12键或右键页面任意处然后选择检查)。将复制的代码粘贴到console里，然后回车执行。（你想装逼？选择这种吧） 刷新页面即失效","categories":[{"name":"前端","slug":"前端","permalink":"https://chenchenwuai.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://chenchenwuai.github.io/tags/javascript/"},{"name":"js脚本","slug":"js脚本","permalink":"https://chenchenwuai.github.io/tags/js%E8%84%9A%E6%9C%AC/"}]},{"title":"无版权图片网站大推荐[搬运]","slug":"no-copyright-image-website","date":"2020-09-23T11:50:04.000Z","updated":"2020-09-24T02:21:31.959Z","comments":true,"path":"no-copyright-image-website/","link":"","permalink":"https://chenchenwuai.github.io/no-copyright-image-website/","excerpt":"无论是写文章、做 PPT 还是找壁纸、换头像，搜图片都是件费时却最出效果的事情。之前小编给大家分享了最好用无版权图片网站之一的 Pixabay，不过图片素材这种东西，尤其是可自由修改使用的图片素材，向来是嫌少不嫌多的。所以这次，小编就把私藏的 60 余家无版权图片网站分享给大家，这家找不到合适的图片？没关系，下一家就有了！从此再也不会被找图这件事情所束缚。","text":"无论是写文章、做 PPT 还是找壁纸、换头像，搜图片都是件费时却最出效果的事情。之前小编给大家分享了最好用无版权图片网站之一的 Pixabay，不过图片素材这种东西，尤其是可自由修改使用的图片素材，向来是嫌少不嫌多的。所以这次，小编就把私藏的 60 余家无版权图片网站分享给大家，这家找不到合适的图片？没关系，下一家就有了！从此再也不会被找图这件事情所束缚。 本次推荐分为第一找图梯队、第二找图梯队、精准找图、分门别类找图、备选方案以及最后的终极找图梯队组成。 # 第一找图梯队根据二八定律，80% 的结果可能来自于 20% 的原因。这在找图片这件事上也适用。虽然这次推荐的无版权图片网站有数十家，但是真正好用的也是只有一部分，而这一部分就足够使用了。 ## Unsplash最知名的无版权图片网站，这家以风景为主，数量足够多，但是很多滤镜感太强，颜色太过厚重，比较适合做壁纸，事实上很多壁纸软件也是直接从这上面下载的图。 ## Pixabay可以说是全球最大的免费图片网站了。图多而且种类足够丰富。这其实也是一家集合网站，可以看到 Unsplash 家的很多图也能在 Pixabay 里搜到。 ## Pexels这家也有很多精美的图片，而且比较好的一点是会有「一周精选」，平常没事的时候来收收图也挺好的。 ## visualhunt数量超级多的无版权图片网站，可以根据颜色进行搜索。 # 第二找图梯队## 别样网找图新欢，旅行日常为主，图片多为用户自己上传，所以在其他地方很少见到。 ## Gratisography每周都会更新，图片角度和题材都比较另类，人物图片不少，另外他家的 logo 也比较另类…… ## StreetWill优点是图片都比较精致小众，缺点是更新慢。 ## IM FREE图片分类详细，可按分类进行筛选。 ## Magdeleine有编辑精选，图片也比较厚重。 ## FancyCrave每天两张手工筛选精品照片，每张都在诉说一个故事。 # 精准找图梯队一般搜索图片都是用关键词进行搜索，搜索单一的关键词还好，一旦稍复杂些的就很容易搜索不出来，这时候你就需要一些精准找图方案。 ## Flickr第一个是雅虎著名的图片社区——Flickr，由于汇集了大批的摄影师，所以 Flickr 家的图片质量都相当之高，不过你可能会说 Flickr 的图片不都是有版权的吗？别急，在「授权」那里选择「所有创用CC」或者「允许商业用途」即可找到那些可以使用的图片啦，由于 Flickr 目前没有简体中文版，所以搜索时用英文或者繁体中文会得到比较好的结果。 ## Google第二个是我大谷歌，谷歌的图片搜索那是相当的强大，选择右侧的「工具」，可以自定义很多东西，包括大小、颜色及使用权限。 # 分类找图## Life of Pix景色建筑为主，色调比较统一。 ## pngimg这个厉害了，2 万多张不同种类的无背景素材图片！全都是抠好图的，直接免费用！。 ## Moveast全部都是旅行风景图片。 ## 旅行日记从名字就能看出来，主要是旅行题材的图片。 ## FoodiesFeed全是好吃的！全是免费的（图片）！ ## Sozai-Page日本的高清食物无背景素材图片。 ## PEEKSPACE超清的太空图片，大多来自 NASA。 ## kaboompics以生活化场景为主，比方说手机、日历之类的，也有一些 mockup。 ## 泼辣有图泼辣修图出的开源摄影网站，全部是无版权的摄影作品。 ## Oliur Rahman各种 iPhone、MacBook 和其他物件的好照片。 ## Pixite Source出品了图像编辑应用 Union、涂色应用 Pigment、矢量制作工具 Assembly 等知名应用的 Pixite，出的一个图库网站，可以搜索图片、材质、色调搜索，里面有很多比较精致的小众插图。 ## Free Nature Stock如网站名，全部是自然风光图片。 ## New Old Stock公共领域的一些老照片，可以免费使用。 ## Freely Photos很多十字架，很多宗教祈祷的图片。 # 备选方案接下来这些就是上述都找不到的情况下的备选方案啦，多达XX个网站，不信没有合适的，哼。 这些网站有的是因为图片质量参差不齐，有的是因为上述的网站已经能够解决需求，所以没怎么刷，大家平时有时间的时候可以多逛逛这些网站，收集一些素材 ## Realistic Shots生活化场景为主，每周 7 张图片。 ## DesignerPics多为局部特写，也可按种类进行筛选。 ## Stokpic有很多人物图片，每两周更新 10 张。 ## JÉSHOOTS2014 年开始运营的无版权图片网站，图片质量还不错。 ## ISO REPUBLIC多走简洁风格。 ## jay mantri个人博客网站，每周更新 7 张图片。 ## picjumbo日常场景居多，有不少数码设备。 ## public domain archive很多黑白照片，也有很多可供个人使用的无版权图片。 ## FFCU图片数量不多，不过有一些好图。 ## StockSnap生活类图片，角度和主题都不错。 ## My Stock Photos这里面的图片都挺好看的。 ## skuawk摄影师拍摄的无版权图片网站，分类浏览。 ## BARN IMAGES有很多比较生活化和小清新的图片。 ## freejpg有一些动物的图片，可直接搜索，也可按照颜色搜索。 ## stockvault大部分为摄影作品，也有少量的插图。 ## Cupcake图片色调厚实，适合做背景图。 ## Trunklog瑞典的一位摄影师旅行所拍摄的照片，全部无偿使用。 接下来介绍一些日本的无版权图片网站。 ## PAKUTASO一看就知道是霓虹国的网站，稀奇古怪的图片一大堆，不过网站 logo 好萌……。 ## Photock日本的无版权图片网站，在里面能很容易地找到富士山、樱花、东京等元素。 ## 無料写真素材日本无版权图片，全部都是日式元素图片，红叶啊、樱花啊、猫啊啥的。 ## photosku还是日本的，基本没用过……。 ## 東京デート日本东京专门的无版权图片网站。 ## 沖縄写真素材恩…日本冲绳专门的无版权图片网站…。 ## Futta日本无版权图片网站，基本为风景图片。 ## Imgstyle如其描述：无料、商业利用可、加工自由、登录不要（全部都是高清植物图片）。 ## ソザイング这家网站有个分类叫做「365日365枚」，就像一本无版权图片的日记本一样，里面有很多很有意思的图片，比方说纯蓝色的水彩、并立的企鹅、一颗土豆等。 # 终极集合挨个网站去搜还是略麻烦，如果有集合类的网站就好了…… ……等会，谁说没有的？！ ## The StocksThe Stocks 就是家无版权图片集合网站，集合了 Unsplash、Stocksy、Pixabay、Free Range、Little Visuals、New Old Stock、Visual Hunt、Super Famous、Startup Stock、GRATISOGRAPHY、GETREFE、PEXELS、jay mantri、Magdeleine、travel coffee、MOVEAST、Barn Images 一共 17 家图片网站，全部 CC0 协议！全部无版权免费使用！ 除了无版权图片外，The Stocks 里还有多家配色、图标、视频、手机/电脑外壳、字体等网站集合…… （不过由于是集合网站，所以刷新速度上可能会慢点，但这网站我依然给满分） ## AllTheFreeStock这个跟 Stocks 差不多，但却更加强大！一个地址，找到所有无版权图片、模型、视频、声效、配色、网页模板、字体、图标、邮件模板…… 简直就是懒人福音。 ## EVERYPIXEL智能搜图工具，可以搜索各大图片网站的图片，并对齐进行精准化的分类。颜色、类型、尺寸、版权，而且可以九宫格单独设置……除了赞美，我无能为力。 ## LibreStock一键搜索 47 家无版权图片网站的精品好图。 ## Finda Photo一键搜索 Barn Images、Life Of Pix 等十余家的无版权图片，网站本身做得很简洁。 如果信息错误或者图片网站已停用，请留言，谢谢 [搬运处]：http://zuimeia.com/app/5022/","categories":[{"name":"photo","slug":"photo","permalink":"https://chenchenwuai.github.io/categories/photo/"}],"tags":[{"name":"Unsplash","slug":"Unsplash","permalink":"https://chenchenwuai.github.io/tags/Unsplash/"},{"name":"copyright","slug":"copyright","permalink":"https://chenchenwuai.github.io/tags/copyright/"}]},{"title":"vscode 插件推荐","slug":"recommended-vscode-plugin","date":"2020-09-11T11:05:04.000Z","updated":"2020-09-23T10:20:53.833Z","comments":true,"path":"recommended-vscode-plugin/","link":"","permalink":"https://chenchenwuai.github.io/recommended-vscode-plugin/","excerpt":"VSCode Plugin","text":"VSCode Plugin 提效类插件Bracket Pair Colorizer快速定位括号,它为代码中的各种结对的括号兄弟们提供了颜色高亮等功能。相关链接: github Veturvue 代码工具,它提供了vue的代码高亮，代码块，错误检查等… Markdown PDF转换md文件为pdf文件,它可以将md文件转换为pdf、html、png、jpeg文件，另外可以设置页眉和页脚。 Markdown TOC快速添加md文件目录,它可以快速将现有的md文件的标题添加为目录","categories":[{"name":"vscode","slug":"vscode","permalink":"https://chenchenwuai.github.io/categories/vscode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://chenchenwuai.github.io/tags/vscode/"}]},{"title":"znu-event 一个简单的event emitter","slug":"javascript/znu-event-A-sample-event-emitter","date":"2020-07-15T10:30:00.000Z","updated":"2020-10-27T01:51:02.838Z","comments":true,"path":"javascript/znu-event-A-sample-event-emitter/","link":"","permalink":"https://chenchenwuai.github.io/javascript/znu-event-A-sample-event-emitter/","excerpt":"znu-event 一个简单的event emitter，无依赖，TypeScript、rollup、自动测试、一键发布到GitHub和NPM。GitHubNPM如果帮助到了你，请给我一个star~ 💖，如果你发现bug，请尽情的在下方评论或者提issue。","text":"znu-event 一个简单的event emitter，无依赖，TypeScript、rollup、自动测试、一键发布到GitHub和NPM。GitHubNPM如果帮助到了你，请给我一个star~ 💖，如果你发现bug，请尽情的在下方评论或者提issue。 安装1npm i znu-event 使用123456import EventEmitter from './znu-event';const emitter = new EventEmitter();emitter.on('add', data=&gt;&#123; console.log(data) // 1&#125;);emitter.emit('add', 1); 方法on(eventName, listener)绑定事件 名称 类型 数据类型 是否必填 说明 eventName 参数 String/Symbol 是 事件名称 listener 参数 Function 是 对应的回调函数 emitter 返回值 EventEmitter — 实例 off(eventName, listener)解除绑定, 如果不填写listener, 那么eventName对应的listener都会被移除. 名称 类型 数据类型 是否必填 说明 eventName 参数 String/Symbol 是 事件名称 listener 参数 Function 是 对应的回调函数 emitter 返回值 EventEmitter — 实例 12345678const callback = data=&gt;&#123; alert(data)&#125;;emitter.on('add', callback);// 解除绑定emitter.off('add', callback);// add事件不会触发emitter.emit('add', 1); once(eventName, listener)绑定事件, 只触发一次 名称 类型 数据类型 是否必填 说明 eventName 参数 String/Symbol 是 事件名称 listener 参数 Function 是 对应的回调函数 emitter 返回值 EventEmitter — 实例 12345678const callback = data=&gt;&#123; alert(data)&#125;;emitter.once('add', callback);// add事件触发emitter.emit('add', 1);// add事件不会触发emitter.emit('add', 1); emit(eventName [, …args])触发事件, 支持任意数量参数 名称 类型 数据类型 是否必填 说明 eventName 参数 String/Symbol 是 事件名称 …args 参数 Any 是 对应的回调函数 emitter 返回值 Boolean — 实例 123456const callback = (a,b,c,d)=&gt;&#123; console(a,b,c,d); // 1,2,3,4&#125;;emitter.once('add', callback);// add事件触发emitter.emit('add', 1,2,3,4); has(eventName)是否绑定了指定事件 名称 类型 数据类型 是否必填 说明 eventName 参数 String/Symbol 是 事件名称 123emitter.on('add', callback);emitter.has('add'); // true eventNames()返回所有绑定事件名称 1emitter.eventNames(); offAll()解除所有绑定事件 12345678910const callback = (a,b,c,d)=&gt;&#123; console(a,b,c,d); // 1,2,3,4&#125;;emitter.on('add', callback);emitter.on('edf', callback);emitter.offAll();// add，edf事件不会触发emitter.emit('add', 1,2,3,4);emitter.emit('edf', 1,2,3,4); destroy()销毁实例 12345678const callback = (a,b,c,d)=&gt;&#123; console(a,b,c,d); // 1,2,3,4&#125;;emitter.once('add', callback);emitter.destroy();// add事件不会触发emitter.emit('add', 1,2,3,4);","categories":[{"name":"前端","slug":"前端","permalink":"https://chenchenwuai.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://chenchenwuai.github.io/tags/javascript/"}]},{"title":"TypeScript学习(1)-基础类型","slug":"typescript/typescript-learning-1","date":"2020-07-10T00:36:22.000Z","updated":"2020-10-26T09:52:22.933Z","comments":true,"path":"typescript/typescript-learning-1/","link":"","permalink":"https://chenchenwuai.github.io/typescript/typescript-learning-1/","excerpt":"学习资源为TypeScript中文网 为了方便，无特殊说明，以下的js表示 JavaScript，ts表示TypeScript","text":"学习资源为TypeScript中文网 为了方便，无特殊说明，以下的js表示 JavaScript，ts表示TypeScript 基础类型基础类型包括 boolean,number,string,数组,元组,enum,any,void,null,undefined.never,object.使用方法 typescript12345// 变量:数据类型let a: number = 1 // 数字let b: string = 'string' // 字符串let c: number[] = [1,2,3] // 数组let d: [number,string] = [1,'hello world'] // 元组 布尔值 boolean1let isTrue: boolean = true // 只能true、false两个值 数字 numberts始于js，所以ts中的所有数字都是浮点数，类型为number。除了支持十进制和十六进制字面量，ts还支持es6中引入的二进制和八进制字面量 1234let decLiteral: number = 6; // 十进制let hexLiteral: number = 0xf00d; // 十六进制 0x 数字0+小写字母xlet binaryLiteral: number = 0b1010; // 二进制 0blet octalLiteral: number = 0o744; // 八进制 0o 字母o 字符串 string1234let nickname: string = 'chenuai'let age: number = 26let hello: string = 'hello, my name is ' + nickname + ', I am ' + age + 'years old.'let hello1: string = `hello, my name is $&#123;nickname&#125;, I am $&#123;age&#125; years old.` // es6写法 数组 []ts表示数组有两种方式1.元素类型后面加[] 12let list: string[] = ['chenuai','hello world']let list2: number[] = [1,2,3] 2.使用数组泛型,之后讲解什么是泛型 1let list: Array&lt;number&gt; = [1,2,4] 元组(Tuple)元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组 123456789let test: [number,string,boolean] = [27,'chenuai',false] let userinfo: [string,number] = ['chenuai',27] // Error : userinfo[1] = ['chenwuai'] // 必须和定义的顺序一样// 但是如果出现数组越界的情况，越界元素值必须是(string|number)类型// 例如：userinfo[2] = '第三个元素' // trueuserinfo[3] = 4 // trueuserinfo[5] = true // error 此处错误，因为布尔值不是string或者number类型// 此处牵扯联合类型，之后讲解。 枚举 enumenum类型是对js标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字 123enum Color &#123;Red, Green, Blue&#125; // 默认从0开始编号enum videoStatus = &#123; connect = 1, play, pause, stop &#125; // 默认从1开始编号enum videoType = &#123; mp4, flv = 2, hls = 4, rtsp &#125; // 默认从0开始，flv为2，hls为4， rtsp没有手动设置值，则它为上一个元素的值+1，所以为5 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。例如，我们知道颜色数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字： 12let colorName: string = Color[2]console.log(colorName) // blue 因为在Color的枚举里面，blue对应的值为2 Any有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用any类型来标记这些变量 1234// 刚开始学ts时，如果不清楚使用什么类型，可以使用any，let notSure: any = 4;notSure = \"maybe a string instead\";notSure = false; 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为Object类型（见下方Object）有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法： 123456let notSure: any = 4;notSure.ifItExists(); // okay, 在运行时，ifItExists方法可能存在notSure.toFixed(); // okay, toFixed方法存在let prettySure: Object = 4;prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'. 属性toFixed 不存在 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： 12let list: any[] = [1, true, \"free\"];list[1] = 100; Void某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： 12345function warnUser(): void &#123; console.log(\"This is my warning message\");&#125;// 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：let unusable: void = undefined; Null 和 Undefinedts里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大： 12let u: undefined = undefined;let n: null = null; 默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。然而，当你指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。为了避免常见问题，尽可能的使用 --strictNullChecks Nevernever类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(\"Something failed\");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; Objectobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。使用object类型，就可以更好的表示像Object.create这样的API。例如： 123456789declare function create(o: object | null): void;create(&#123; prop: 0 &#125;); // OKcreate(null); // OKcreate(42); // Errorcreate(\"string\"); // Errorcreate(false); // Errorcreate(undefined); // Error 类型断言有时候你会遇到这样的情况，你会比ts更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 ts会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 其一是“尖括号”语法： 12let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 另一个为as语法： 12let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在ts里使用JSX时，只有 as语法断言是被允许的。","categories":[{"name":"前端","slug":"前端","permalink":"https://chenchenwuai.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://chenchenwuai.github.io/tags/TypeScript/"}]},{"title":"nginx开启gzip和缓存","slug":"nginx/enable-nginx-gzip-and-cache","date":"2020-06-16T11:15:55.000Z","updated":"2020-09-24T06:22:52.322Z","comments":true,"path":"nginx/enable-nginx-gzip-and-cache/","link":"","permalink":"https://chenchenwuai.github.io/nginx/enable-nginx-gzip-and-cache/","excerpt":"极简配置在站点的配置文件中(例如website.conf)的server中添加gzip on.","text":"极简配置在站点的配置文件中(例如website.conf)的server中添加gzip on. website.conf123server&#123; gzip on;&#125; 常规配置按照下面代码进行配置 website.conf12345678910server&#123; gzip on; # 是否开启gzip gzip_buffers 32 4K; # 缓冲(压缩在内存中缓冲几块? 每块多大?) gzip_comp_level 6; # 推荐6 压缩级别(级别越高,压的越小,越浪费CPU计算资源) gzip_min_length 1k; # 开始压缩的最小长度(再小就不要压缩了,意义不在) gzip_types application/javascript text/css text/xml; # 对哪些类型的文件用压缩 如txt,xml,html ,css gzip_disable \"MSIE [1-6]\\.\"; #正则匹配UA，配置禁用gzip条件。此处表示ie6及以下不启用gzip（因为ie低版本不支持） gzip_http_version 1.1; # 开始压缩的http协议版本(可以不设置,目前几乎全是1.1协议) gzip_vary on; # 是否传输gzip压缩标志&#125; 保存并重启nginx，刷新页面（为了避免缓存，请强制刷新）就能看到效果了。以谷歌浏览器为例，通过F12看请求的响应头部。 gzip参数详解gzipwebsite.conf12#打开或关闭gzipgzip on; # on | off 解释：打开或关闭gzip gzip_bufferswebsite.conf123# 设置用于处理请求压缩的缓冲区数量和大小# 比如32 4K表示按照内存页（one memory page）大小以4K为单位（即一个系统中内存页为4K），申请32倍的内存空间。建议此项不设置，使用默认值gzip_buffers 32 4k; gzip_comp_levelwebsite.conf12345# 设置gzip压缩级别，取值 1-9# 值越高越消耗cpu的性能，高并发情况下cpu可能达到100%# 级别越底压缩速度越快文件压缩比越小，反之速度越慢文件压缩比越大，一般6之后压缩比很难提升# 一方面，gzip_comp_level 1的压缩能力已经够用。另一方面，压缩一定要和静态资源缓存相结合，缓存压缩后的版本，否则每次都压缩高负载下服务器肯定吃不住。gzip_comp_level 2; gzip_disablewebsite.conf12# 表明哪些UA(usergent)头不使用gzip压缩，可以正则gzip_disable \"MSIE [1-6]\\.\"; gzip_min_lengthwebsite.conf12# 当返回内容大于此值时才会使用gzip进行压缩,以k为单位,当值为0时，所有页面都进行压缩。gzip_min_length 1k; # 100 | 500 | 1k gzip_http_versionwebsite.conf12# 用于识别http协议的版本，早期的浏览器不支持gzip压缩，用户会看到乱码，所以为了支持前期版本加了此选项。默认在http/1.0的协议下不开启gzip压缩。gzip_http_version 1.1; # 1.0 | 1.1 gzip_proxiedwebsite.conf1234567891011# Nginx做为反向代理的时候启用:# off – 关闭所有的代理结果数据压缩，默认值# expired – 如果header中包含”Expires”头信息，启用压缩# no-cache – 如果header中包含”Cache-Control:no-cache”头信息，启用压缩# no-store – 如果header中包含”Cache-Control:no-store”头信息，启用压缩# private – 如果header中包含”Cache-Control:private”头信息，启用压缩# no_last_modified – 启用压缩，如果header中包含”Last_Modified”头信息，启用压缩# no_etag – 启用压缩，如果header中包含“ETag”头信息，启用压缩# auth – 启用压缩，如果header中包含“Authorization”头信息，启用压缩# any – 无条件压缩所有结果数据gzip_proxied off; gzip_varywebsite.conf12# 浏览器请求增加响应头\"Vary: Accept-Encoding\"gzip_vary on; gzip_typeswebsite.conf123# 设置需要压缩的MIME类型,如果不在设置类型范围内的请求不进行压缩，其中的值可以在 mime.types 文件中找到# 压缩字体类型 font/ttf font/otf image/svg+xmlgzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml; 这里需要说明一些特殊的类型，使用”字体类型”的资源，而这些资源类型往往会被忽略，且这些资源又比较大，没有被压缩很不合算。（可以参考：http://www.darrenfang.com/2015/01/setting-up-http-cache-and-gzip-with-nginx/） 开启缓存website.conf12345678910111213141516171819202122# 缓存图片location ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ &#123; access_log off; expires 30d; #根据自己需要修改时间&#125;#缓存js、css、视频文件location ~* ^.+\\.(css|js|txt|xml|swf|wav)$ &#123; access_log off; expires 24h;&#125;# 缓存html类型文件location ~* ^.+\\.(html|htm)$ &#123; expires 1h;&#125;# 缓存字体文件，配合gzip更好location ~* ^.+\\.(eot|ttf|otf|woff|svg)$ &#123; access_log off; expires 30d;&#125;","categories":[{"name":"nginx","slug":"nginx","permalink":"https://chenchenwuai.github.io/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://chenchenwuai.github.io/tags/nginx/"},{"name":"gzip","slug":"gzip","permalink":"https://chenchenwuai.github.io/tags/gzip/"}]},{"title":"mysql root账户远程不能登录解决方法","slug":"database/mysql-remote-can-not-login","date":"2019-06-05T14:29:31.000Z","updated":"2020-09-23T08:54:30.257Z","comments":true,"path":"database/mysql-remote-can-not-login/","link":"","permalink":"https://chenchenwuai.github.io/database/mysql-remote-can-not-login/","excerpt":"原因mysql 远程不能登录一般是没有设置 host 为 % 或者对应的ip地址这种情况下一般是通过修改原来 root 账户的 host 为 % 来进行远程登录，但是这种设置也是有一个缺点，就是某种情况下本地命令行就不能登录了。","text":"原因mysql 远程不能登录一般是没有设置 host 为 % 或者对应的ip地址这种情况下一般是通过修改原来 root 账户的 host 为 % 来进行远程登录，但是这种设置也是有一个缺点，就是某种情况下本地命令行就不能登录了。 解决方法所以正确的做法是新创建一个 root 账户，但是 host 为 % 。具体操作为 12GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;12306&#39; WITH GRANT OPTION; -- 12306 是密码flush privileges; 这时候在使用远程连接工具登录 root 账户就可以了。总结一下，就是如果需要用户在本地和远程都可以连接，则需要创建两个账户，一个 host 为 localhost;另一个 host 为 %,当然这种方式并不安全，建议两个用户密码不一样 语句分析 ALL PRIVILEGES 表示将所有权限授予给用户。也可指定具体的权限，如：SELECT,CREATE,DROP等。 GRANT SELECT,CREATE,UPDATE,ALTER,DROP ON…. ON 表示这些权限对哪些数据库和表生效，格式：数据库名.表名，这里写“*”表示所有数据库，所有表。如果我要指定将权限应用到test库的user表中，可以这么写：test.user TO 将权限授予哪个用户。格式：”用户名”@”登录IP或域名或%”。%表示没有限制，在任何主机都可以登录。比如：”web_user”@”192.168.0.%”,表示web_user这个用户只能在192.168.0IP段登录 IDENTIFIED BY 指定用户的登录密码 WITH GRANT OPTION 表示允许用户将自己的权限授权给其它用户 flush privileges 更新权限信息使用GRANT给用户添加权限，权限会自动叠加，不会覆盖之前授予的权限，比如你先给用户添加一个SELECT权限，后来又给用户添加了一个INSERT权限，那么该用户就同时拥有了SELECT和INSERT权限。 详细的权限列表信息","categories":[{"name":"mysql","slug":"mysql","permalink":"https://chenchenwuai.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://chenchenwuai.github.io/tags/mysql/"}]},{"title":"CentOS 7 + Apache 配置https + wss转发","slug":"apache/enable-apache-https-and-forward-wss","date":"2019-04-06T01:08:00.000Z","updated":"2020-09-24T06:22:34.845Z","comments":true,"path":"apache/enable-apache-https-and-forward-wss/","link":"","permalink":"https://chenchenwuai.github.io/apache/enable-apache-https-and-forward-wss/","excerpt":"安装openssl库1.检查是否已安装 openssl 1234openssl version -a# 打印出下面类似的信息表明已安装# OpenSSL 1.0.2k-fips 26 Jan 2017.....# built on: reproducible build, date unspecified","text":"安装openssl库1.检查是否已安装 openssl 1234openssl version -a# 打印出下面类似的信息表明已安装# OpenSSL 1.0.2k-fips 26 Jan 2017.....# built on: reproducible build, date unspecified 如果未安装，可以使用 yum install openssl 或参考其他方式 2.检查apache是否已安装ssl模块 查看 /etc/httpd/conf.d/ssl.conf 文件是否存在，如果不存在 使用命令安装 1yum install mod_ssl 3.检查是否已启用apache的 proxy模块 打开 /etc/httpd/conf.modules.d/文件夹，查看是否存在 proxy.conf 文件名(有可能是00-proxy.conf)的文件,如果不存在，可能需要重新编译安装apache，请联系服务器维护人员。如果存在查看时候有一下代码 1234LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_http_module modules/mod_proxy_http.soLoadModule proxy_wstunnel_module modules/mod_proxy_wstunnel.soLoadModule proxy_connect_module modules/mod_proxy_connect.so 不存在请联系服务器维护人员 生成ssl证书1.如果没有证书文件，可以创建本地文件测试 输入命令，生成2048位加密私钥 1openssl genrsa -out server1.key 2048 然后输入命令，生成证书签名请求（CSR），这里需要填写许多信息，如国家，省市，公司，域名等，域名 必须填写正确，其他可以随便填写 1openssl req -new -key server1.key -out server1.csr 最后输入命令，生成类型为X509的自签名证书。有效期设置3650天，即有效期为10年 1openssl x509 -req -days 3650 -in server1.csr -signkey server1.key -out server1.crt 参考文件连接 https://www.linuxidc.com/Linux/2018-08/153555.htm 2.移动证书文件 在 /etc/httpd/文件夹下面创建一个 crt文件夹，将提供的证书文件移动到里面。 12xxxx.crt # 证书文件xxxx.key # 证书秘钥文件 配置ssl 打开 /etc/httpd/conf.d/ssl.conf 文件，找到 &lt;VirtualHost _default_:443&gt; 这一行，在其后面添加 ssl.conf12345DocumentRoot \"/var/www/html\" # 指向web的地址，一般不需要修改# 配置域名，域名必须和证书的名称一致 # 例如 aaaa.com -&gt; ServerName aaaa.com:443ServerName www.example.com:443 然后找到 SSLEngine on 这一行代码，在下面添加 ssl.conf123456789101112SSLProxyEngine onProxyRequests Off# 转发 streams流ProxyPass /streams http://127.0.0.1:6666/streams# 状态码302相关ProxyPassReverse /streams http://127.0.0.1:6666/streams# 转发wss 协议到 ws协议ProxyPass /wss ws://127.0.0.1:8888# 状态码302相关ProxyPassReverse /wss ws://127.0.0.1:8888 然后找到 SSLHonorCipherOrder on这行代码把前面的 # 号去掉 然后找到 SSLCertificateFile /etc/pki/tls/certs/localhost.crt 把里面的文件地址改为证书文件crt文件的地址/etc/httpd/crt/xxxx.crt 然后找到 SSLCertificateKeyFile /etc/pki/tls/private/localhost.key 把里面的文件地址改为证书秘钥文件key文件的地址/etc/httpd/crt/xxxx.key 然后保存，重启httpd服务 systemctl restart httpd 配置过的ssl.conf文件 可参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228 ## When we also provide SSL we have to listen to the # the HTTPS port in addition.#Listen 443 https#### SSL Global Context#### All SSL configuration in this context applies both to## the main server and all SSL-enabled virtual hosts.### Pass Phrase Dialog:# Configure the pass phrase gathering process.# The filtering dialog program (`builtin' is a internal# terminal dialog) has to provide the pass phrase on stdout.SSLPassPhraseDialog exec:/usr/libexec/httpd-ssl-pass-dialog# Inter-Process Session Cache:# Configure the SSL Session Cache: First the mechanism # to use and second the expiring timeout (in seconds).SSLSessionCache shmcb:/run/httpd/sslcache(512000)SSLSessionCacheTimeout 300# Pseudo Random Number Generator (PRNG):# Configure one or more sources to seed the PRNG of the # SSL library. The seed data should be of good random quality.# WARNING! On some platforms /dev/random blocks if not enough entropy# is available. This means you then cannot use the /dev/random device# because it would lead to very long connection times (as long as# it requires to make more entropy available). But usually those# platforms additionally provide a /dev/urandom device which doesn't# block. So, if available, use this one instead. Read the mod_ssl User# Manual for more details.SSLRandomSeed startup file:/dev/urandom 256SSLRandomSeed connect builtin#SSLRandomSeed startup file:/dev/random 512#SSLRandomSeed connect file:/dev/random 512#SSLRandomSeed connect file:/dev/urandom 512## Use \"SSLCryptoDevice\" to enable any supported hardware# accelerators. Use \"openssl engine -v\" to list supported# engine names. NOTE: If you enable an accelerator and the# server does not start, consult the error logs and ensure# your accelerator is functioning properly. #SSLCryptoDevice builtin#SSLCryptoDevice ubsec#### SSL Virtual Host Context##&lt;VirtualHost _default_:443&gt;# General setup for the virtual host, inherited from global configurationDocumentRoot \"/var/www/html\"ServerName aaaaaaaaaa.com:443# Use separate log files for the SSL virtual host; note that LogLevel# is not inherited from httpd.conf.ErrorLog logs/ssl_error_logTransferLog logs/ssl_access_logLogLevel warn# SSL Engine Switch:# Enable/Disable SSL for this virtual host.SSLEngine onSSLProxyEngine onProxyRequests Off ProxyPass /streams http://127.0.0.1:3096/streams ProxyPassReverse /streams http://127.0.0.1:3096/streamsProxyPass /wss ws://127.0.0.1:3098 ProxyPassReverse /wss ws://127.0.0.1:3098# SSL Protocol support:# List the enable protocol levels with which clients will be able to# connect. Disable SSLv2 access by default:SSLProtocol all -SSLv2 -SSLv3# SSL Cipher Suite:# List the ciphers that the client is permitted to negotiate.# See the mod_ssl documentation for a complete list.SSLCipherSuite HIGH:3DES:!aNULL:!MD5:!SEED:!IDEA# Speed-optimized SSL Cipher configuration:# If speed is your main concern (on busy HTTPS servers e.g.),# you might want to force clients to specific, performance# optimized ciphers. In this case, prepend those ciphers# to the SSLCipherSuite list, and enable SSLHonorCipherOrder.# Caveat: by giving precedence to RC4-SHA and AES128-SHA# (as in the example below), most connections will no longer# have perfect forward secrecy - if the server's key is# compromised, captures of past or future traffic must be# considered compromised, too.#SSLCipherSuite RC4-SHA:AES128-SHA:HIGH:MEDIUM:!aNULL:!MD5SSLHonorCipherOrder on # Server Certificate:# Point SSLCertificateFile at a PEM encoded certificate. If# the certificate is encrypted, then you will be prompted for a# pass phrase. Note that a kill -HUP will prompt again. A new# certificate can be generated using the genkey(1) command.SSLCertificateFile /etc/httpd/crt/server1.crt# Server Private Key:# If the key is not combined with the certificate, use this# directive to point at the key file. Keep in mind that if# you've both a RSA and a DSA private key you can configure# both in parallel (to also allow the use of DSA ciphers, etc.)SSLCertificateKeyFile /etc/httpd/crt/server1.key# Server Certificate Chain:# Point SSLCertificateChainFile at a file containing the# concatenation of PEM encoded CA certificates which form the# certificate chain for the server certificate. Alternatively# the referenced file can be the same as SSLCertificateFile# when the CA certificates are directly appended to the server# certificate for convinience.#SSLCertificateChainFile /etc/pki/tls/certs/server-chain.crt# Certificate Authority (CA):# Set the CA certificate verification path where to find CA# certificates for client authentication or alternatively one# huge file containing all of them (file must be PEM encoded)#SSLCACertificateFile /etc/pki/tls/certs/ca-bundle.crt# Client Authentication (Type):# Client certificate verification type and depth. Types are# none, optional, require and optional_no_ca. Depth is a# number which specifies how deeply to verify the certificate# issuer chain before deciding the certificate is not valid.#SSLVerifyClient require#SSLVerifyDepth 10# Access Control:# With SSLRequire you can do per-directory access control based# on arbitrary complex boolean expressions containing server# variable checks and other lookup directives. The syntax is a# mixture between C and Perl. See the mod_ssl documentation# for more details.#&lt;Location /&gt;#SSLRequire ( %&#123;SSL_CIPHER&#125; !~ m/^(EXP|NULL)/ \\# and %&#123;SSL_CLIENT_S_DN_O&#125; eq \"Snake Oil, Ltd.\" \\# and %&#123;SSL_CLIENT_S_DN_OU&#125; in &#123;\"Staff\", \"CA\", \"Dev\"&#125; \\# and %&#123;TIME_WDAY&#125; &gt;= 1 and %&#123;TIME_WDAY&#125; &lt;= 5 \\# and %&#123;TIME_HOUR&#125; &gt;= 8 and %&#123;TIME_HOUR&#125; &lt;= 20 ) \\# or %&#123;REMOTE_ADDR&#125; =~ m/^192\\.76\\.162\\.[0-9]+$/#&lt;/Location&gt;# SSL Engine Options:# Set various options for the SSL engine.# o FakeBasicAuth:# Translate the client X.509 into a Basic Authorisation. This means that# the standard Auth/DBMAuth methods can be used for access control. The# user name is the `one line' version of the client's X.509 certificate.# Note that no password is obtained from the user. Every entry in the user# file needs this password: `xxj31ZMTZzkVA'.# o ExportCertData:# This exports two additional environment variables: SSL_CLIENT_CERT and# SSL_SERVER_CERT. These contain the PEM-encoded certificates of the# server (always existing) and the client (only existing when client# authentication is used). This can be used to import the certificates# into CGI scripts.# o StdEnvVars:# This exports the standard SSL/TLS related `SSL_*' environment variables.# Per default this exportation is switched off for performance reasons,# because the extraction step is an expensive operation and is usually# useless for serving static content. So one usually enables the# exportation for CGI and SSI requests only.# o StrictRequire:# This denies access when \"SSLRequireSSL\" or \"SSLRequire\" applied even# under a \"Satisfy any\" situation, i.e. when it applies access is denied# and no other module can change it.# o OptRenegotiate:# This enables optimized SSL connection renegotiation handling when SSL# directives are used in per-directory context. #SSLOptions +FakeBasicAuth +ExportCertData +StrictRequire&lt;Files ~ \"\\.(cgi|shtml|phtml|php3?)$\"&gt; SSLOptions +StdEnvVars&lt;/Files&gt;&lt;Directory \"/var/www/cgi-bin\"&gt; SSLOptions +StdEnvVars&lt;/Directory&gt;# SSL Protocol Adjustments:# The safe and default but still SSL/TLS standard compliant shutdown# approach is that mod_ssl sends the close notify alert but doesn't wait for# the close notify alert from client. When you need a different shutdown# approach you can use one of the following variables:# o ssl-unclean-shutdown:# This forces an unclean shutdown when the connection is closed, i.e. no# SSL close notify alert is send or allowed to received. This violates# the SSL/TLS standard but is needed for some brain-dead browsers. Use# this when you receive I/O errors because of the standard approach where# mod_ssl sends the close notify alert.# o ssl-accurate-shutdown:# This forces an accurate shutdown when the connection is closed, i.e. a# SSL close notify alert is send and mod_ssl waits for the close notify# alert of the client. This is 100% SSL/TLS standard compliant, but in# practice often causes hanging connections with brain-dead browsers. Use# this only for browsers where you know that their SSL implementation# works correctly. # Notice: Most problems of broken clients are also related to the HTTP# keep-alive facility, so you usually additionally want to disable# keep-alive for those clients, too. Use variable \"nokeepalive\" for this.# Similarly, one has to force some clients to use HTTP/1.0 to workaround# their broken HTTP/1.1 implementation. Use variables \"downgrade-1.0\" and# \"force-response-1.0\" for this.BrowserMatch \"MSIE [2-5]\" \\ nokeepalive ssl-unclean-shutdown \\ downgrade-1.0 force-response-1.0# Per-Server Logging:# The home of a custom SSL log file. Use this when you want a# compact non-error SSL logfile on a virtual host basis.CustomLog logs/ssl_request_log \\ \"%t %h %&#123;SSL_PROTOCOL&#125;x %&#123;SSL_CIPHER&#125;x \\\"%r\\\" %b\"&lt;/VirtualHost&gt;","categories":[{"name":"apache","slug":"apache","permalink":"https://chenchenwuai.github.io/categories/apache/"}],"tags":[{"name":"centos7","slug":"centos7","permalink":"https://chenchenwuai.github.io/tags/centos7/"},{"name":"apache","slug":"apache","permalink":"https://chenchenwuai.github.io/tags/apache/"},{"name":"https","slug":"https","permalink":"https://chenchenwuai.github.io/tags/https/"},{"name":"wss","slug":"wss","permalink":"https://chenchenwuai.github.io/tags/wss/"}]},{"title":"忘记 Mysql root账户密码如何修改","slug":"database/change-mysql-root-password","date":"2018-03-21T15:06:11.000Z","updated":"2020-09-23T08:54:31.057Z","comments":true,"path":"database/change-mysql-root-password/","link":"","permalink":"https://chenchenwuai.github.io/database/change-mysql-root-password/","excerpt":"关闭mysql登录验证打开命令行界面 然后输入打开 my.cnf 配置文件的命令 1vim /etc/my.cnf","text":"关闭mysql登录验证打开命令行界面 然后输入打开 my.cnf 配置文件的命令 1vim /etc/my.cnf 在 [mysqld] 的段中加上一句：skip-grant-tables my.cnf1234[mysqld] datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock skip-grant-tables 然后保存重启mysql 12// mariadb 如果是mysql，则把mariadb改为mysqlsystemctl restart mariadb 无密码登录然后登录 12mysql -uroot -p// 然后直接回车，要求输入密码的时候也直接回车 修改密码登录之后选择mysql这个数据库然后修改用户密码 12use mysql; --选择要操作的数据库UPDATE user SET password &#x3D; password(&#39;vbox_12306&#39;) WHERE User &#x3D; &#39;root&#39;; -- vbox_12306 为密码 回车之后显示下面的表示成功 12Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 如果提示下面的错误 1The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement 刷新权限则运行一下刷新权限的命令 1flush privileges; 然后在执行上面的 update 命令，执行成功之后再次执行 flush 刷新权限命令 开启密码登录此时退出mysql 再次打开 my.cnf 配置文件 把已开始加入的 skip-grant-tables 删除 :wq 保存 ，然后重启mysql 1systemctl restart mariadb 然后安正常步骤登录mysql。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://chenchenwuai.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://chenchenwuai.github.io/tags/mysql/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-02-20T04:50:04.000Z","updated":"2020-09-24T06:25:34.770Z","comments":true,"path":"hello-world/","link":"","permalink":"https://chenchenwuai.github.io/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"CSS","slug":"CSS","permalink":"https://chenchenwuai.github.io/categories/CSS/"},{"name":"php","slug":"php","permalink":"https://chenchenwuai.github.io/categories/php/"},{"name":"前端","slug":"前端","permalink":"https://chenchenwuai.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"photo","slug":"photo","permalink":"https://chenchenwuai.github.io/categories/photo/"},{"name":"vscode","slug":"vscode","permalink":"https://chenchenwuai.github.io/categories/vscode/"},{"name":"nginx","slug":"nginx","permalink":"https://chenchenwuai.github.io/categories/nginx/"},{"name":"mysql","slug":"mysql","permalink":"https://chenchenwuai.github.io/categories/mysql/"},{"name":"apache","slug":"apache","permalink":"https://chenchenwuai.github.io/categories/apache/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://chenchenwuai.github.io/tags/CSS/"},{"name":"BFC","slug":"BFC","permalink":"https://chenchenwuai.github.io/tags/BFC/"},{"name":"盒模型","slug":"盒模型","permalink":"https://chenchenwuai.github.io/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"name":"mysql","slug":"mysql","permalink":"https://chenchenwuai.github.io/tags/mysql/"},{"name":"php","slug":"php","permalink":"https://chenchenwuai.github.io/tags/php/"},{"name":"mysql.sock","slug":"mysql-sock","permalink":"https://chenchenwuai.github.io/tags/mysql-sock/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://chenchenwuai.github.io/tags/TypeScript/"},{"name":"javascript","slug":"javascript","permalink":"https://chenchenwuai.github.io/tags/javascript/"},{"name":"js脚本","slug":"js脚本","permalink":"https://chenchenwuai.github.io/tags/js%E8%84%9A%E6%9C%AC/"},{"name":"Unsplash","slug":"Unsplash","permalink":"https://chenchenwuai.github.io/tags/Unsplash/"},{"name":"copyright","slug":"copyright","permalink":"https://chenchenwuai.github.io/tags/copyright/"},{"name":"vscode","slug":"vscode","permalink":"https://chenchenwuai.github.io/tags/vscode/"},{"name":"nginx","slug":"nginx","permalink":"https://chenchenwuai.github.io/tags/nginx/"},{"name":"gzip","slug":"gzip","permalink":"https://chenchenwuai.github.io/tags/gzip/"},{"name":"centos7","slug":"centos7","permalink":"https://chenchenwuai.github.io/tags/centos7/"},{"name":"apache","slug":"apache","permalink":"https://chenchenwuai.github.io/tags/apache/"},{"name":"https","slug":"https","permalink":"https://chenchenwuai.github.io/tags/https/"},{"name":"wss","slug":"wss","permalink":"https://chenchenwuai.github.io/tags/wss/"}]}